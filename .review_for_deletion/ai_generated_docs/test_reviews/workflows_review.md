# workflows.sh Review

_Review executed per `tests/TEST_REVIEW_PLAN.md`._

## Phase 1 – Initial Assessment
- **File:** `tests/workflows.sh`
- **Purpose:** Exercises three end-to-end workflows: creating reminders from notes, asking chat questions against document fixtures, and validating that a freshly generated backup can be restored.
- **Dependencies:**
  - Relies on helper utilities from `tests/common.sh` (`ensure_note_fixture`, `ensure_document_fixture`, `assert_*`, `run_test`, etc.).
  - Requires environment variables such as `BASE_URL`, `TOKEN`, `TEST_DIR`, `NOTE_FIXTURE_ID`, `BACKUP_ROOT`, `LATEST_BACKUP_TS`, and Docker access to `brainda-postgres`.
  - Interacts with API endpoints (`/api/v1/reminders`, `/api/v1/chat`) and the backing Postgres instance via `psql_query`/`docker exec`.

## Phase 2 – Testing Methodology
- Tests are grouped inside `workflow_check` and dispatched from `run_workflow_tests`, which keeps organization consistent with other stage suites.
- Each workflow is linear (setup → action → assertions) but there is no teardown to remove created reminders or temporary DBs, which can leave state behind for subsequent runs.
- Positive cases are covered; no negative/error-path checks exist (e.g., reminder creation failures, chat timeouts, restore failures).

## Phase 3 – Error Handling
- `set -euo pipefail` is enabled globally.
- `document_to_answer` captures HTTP status codes explicitly; `note_to_reminder` does not, so API failures manifest only as empty IDs without context.
- No traps/cleanup handlers are present in case a workflow exits early.

## Phase 4 – Debugging & Observability
- Logging is deferred to the shared `run_test` harness; individual workflows emit little contextual output.
- When reminder creation fails there is no visibility into the HTTP response body because it is discarded after extracting the ID.
- The chat workflow saves `workflow-rag.json` for debugging, which is helpful, but the file is overwritten each run and never summarized in logs.

## Phase 5 – Timing & Synchronization
- Workflows assume synchronous completion (e.g., `run_backup_job` immediately followed by `stage4_restore_temp_db`) without polling to ensure asynchronous jobs/containers are ready. If backups run asynchronously this can race.

## Phase 6 – Performance & Efficiency
- No obvious sleeps/polling loops. However, `run_backup_job`+`stage4_restore_temp_db` always run sequentially even if a recent backup already exists; the suite could re-use cached backups to avoid redundant work.

## Phase 7 – Code Quality & Maintainability
- Consistent style/indentation, but repeated inline JSON payload construction could be factored into helpers for readability.
- Lacks header comments describing expected prerequisites (fixtures, env vars) for future maintainers.

## Phase 8 – Security & Safety
- Inputs are mostly static; commands are quoted. Reminder IDs are interpolated into SQL without escaping, but they are UUIDs generated by the API.

## Phase 9 – Integration & Dependencies
- Assumes helper functions from other scripts are already sourced; `run_workflow_tests` itself does not source them, so calling it standalone would fail.
- Docker/psql availability is assumed but never checked within this file.

## Phase 10 – Findings & Recommendations

### Issues
| Severity | Issue | Recommendation |
| --- | --- | --- |
| **High** | `note_to_reminder` leaves real reminder records behind and never deletes them. Over time this bloats the fixtures DB and can make subsequent runs depend on polluted state, violating the plan’s isolation criteria (Phases 2 & 4). | After assertions, delete the reminder via API/SQL or wrap creation in a helper that automatically cleans up. |
| **Medium** | Reminder creation does not capture HTTP status codes or response bodies. Failures surface only as `assert_not_empty` errors, providing little debugging context and making it hard to distinguish API errors from parsing issues (Phases 3 & 4). | Capture `curl` status like the chat workflow (`-w "%{http_code}"`) and log the response/validation error when the status is not 2xx. |
| **Medium** | `backup_restore_workflow` only asserts that `note_count` is non-empty, not that any rows were restored. A restore that yields zero rows (or a string error) would still pass because non-empty strings satisfy the check (Phases 2 & 3). | Use `assert_greater_than "$note_count" "0"` and verify additional tables (reminders/documents) to ensure the snapshot actually contains data. |
| **Medium** | The restore workflow assumes `run_backup_job` completed and that `LATEST_BACKUP_TS` is populated, but there is no assertion before invoking `stage4_restore_temp_db`. If no backup is produced the restore silently operates on `null`, giving confusing failures (Phases 3 & 5). | Assert that `LATEST_BACKUP_TS` is non-empty after `run_backup_job` and abort early with a descriptive error if discovery fails. |
| **Low** | The chat workflow only checks for a non-zero citation count and never validates that an answer was returned or that citations reference the uploaded fixture. This weakens coverage of the intended RAG behavior (Phase 2). | Assert that `.answer` is non-empty and that each citation’s `document_id` matches the known fixture ID. |
| **Low** | There is no teardown for the temporary `vib_restore_test` database created by `stage4_restore_temp_db`. The helper may handle cleanup, but nothing in this file documents or enforces it, which can leave stray databases (Phases 2 & 4). | Explicitly drop the temporary DB (or call a cleanup helper) once validations complete. |

### Quick Wins
- Reuse the HTTP status handling pattern from `document_to_answer` inside `note_to_reminder` to gain immediate observability.
- After counting notes in the restored DB, drop the temporary database to prevent accumulation.

### Refactoring Opportunities
- Extract repeated payload creation and API-call boilerplate into helper functions in `tests/common.sh` for consistency with other suites.
- Consider parameterizing workflows so they can run independently (e.g., `./tests/workflows.sh workflow_note_to_reminder`) to aid targeted debugging.

### Follow-up Actions
1. Confirm whether `stage4_restore_temp_db` already drops `vib_restore_test`; if not, add explicit cleanup.
2. Add negative-path tests (e.g., invalid note IDs, expired reminders) once positive path is hardened.
3. Evaluate whether backups can be reused across runs to shorten execution time.

---
Please let me know if you’d like me to start implementing these fixes.
